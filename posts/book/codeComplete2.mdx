---
title: "코드 컴플리트2"
category: "book"
date: "2022-07-31"
---

## 5장 구현 설계

1. 바람직한 설계의 특징

- 복잡성 최소화
- 유지보수의 편리함
- 느슨한 결합
- 확장성
- 재사용성
- 높은 팬인
- 낮은 팬아웃
- 이식성
- 간결성
- 계층화
- 표준 기법들

2. 설계 수준

- 소프트웨어 시스템
- 서브시스템이나 패키지로 분할
  - 공통적인 서브시스템 (비즈니스 규칙, 사용자 인터페이스, 데이터베이스 접근, 시스템 의존성)
- 클래스로 분할
- 루틴으로 분할
- 내부 루틴 설계

3. 설계 원칙

- 객체 설계
  - 각 객체가 무엇을 할 수 있는지 결정한다
  - 각 객체가 다른 객체에 무엇을 할 수 있는지 결정한다
  - 각 객체에서 다른 객체에 보일 부분을 결정한다
  - 각 객체의 인터페이스를 정의한다
- 일관성 있게 추상화 하라
- 구현 세부 사항을 캡슐화하라
- 상속이 설계를 단순화 할 수 있을 때 상속하라
- 비밀을 숨겨라(정보 은닉)
- 변경될 것 같은 영역을 찾아라
  - 비즈니스 규칙, 하드웨어 의존성, 입력과 출력, 표준을 따르지 않는 언어 기능, 어려운 설계 및 구현 부분, 상태 변수
- 결합을 느슨하게 유지하라
- 일반적으로 널리 사용되는 디자인 패턴을 찾아라
  - 패턴은 이미 만들어진 추상화를 제공함으로써 복잡성을 줄인다.
  - 일반적으로 널리 사용되는 해결책의 세부사항들을 규정함으로써 오류를 줄인다.
  - 대안을 제안함으로써 발견적 학습의 가치를 제공한다.
  - 설계에 대해 수준 높은 논의를 할 수 있게 해서 의사소통을 원할하게 한다.

4. 발견적 학습기법

- 문제의 이해 > 계획 고안 > 계획 실행 > 검토

## 6장 클래스 다루기

1. 추상 데이터형(ADT)
   Abstract Data Type

- 장점
  - 구현 세부 사항을 감출 수 있다.
  - 변경이 전체에 영향을 미치지 않는다.
  - 인터페이스가 더 많은 정보를 제공하도록 만들 수 있다.
  - 성능을 향상시키기 쉽다
  - 프로그램이 명백하게 정확해진다.
  - 프로그램의 가독성이 높아진다.
  - 전체 프로그램에 데이터를 넘길 필요가 없다.
  - 저수준 구현 구조체 대신 현실 세계의 개체를 다룰 수 있다.

2. 좋은 클래스 인터페이스

- 좋은 추상화
  - 클래스 인터페이스가 일관된 추상화 수준을 갖도록 한다.
  - 클래스가 구현하고 있는 추상화가 무엇인지 이해해야 한다.
  - 서로 반대되는 기능을 갖는 서비스 쌍을 제공하라.
  - 관련이 없는 정보를 다른 클래스로 옮겨라.
  - 가능하면 인터페이스를 의미론적이기보다는 프로그래밍적으로 만들어라.
  - 코드 변경 시 인터페이스의 추상화가 망가지지 않도록 주의하라
  - 인터페이스 추상화에 맞지 않는 공개 멤버를 추가하지 말라
  - 추상화와 응집도를 함께 고려하라
- 좋은 캡슐화
  - 클래스와 멤버의 접근성을 최소화하라
  - 멤버 데이터를 public으로 노출하지 말라
  - 내부 구현 세부 사항을 클래스의 인터페이스에 입력하지 말라
  - 클래스의 사용자를 가정하지 말라
  - 프렌드 클래스를 피하라
  - 어떤 루틴이 공개 루틴만 사용한다고 해서 public 인터페이스에 두지 말라.
  - 코드를 작성할 때의 편의성보다 가독성이 높은 코드를 작성하라.
  - 캡슐화의 의미론적인 위반을 각별히 주의하라
  - 지나치게 밀접한 결핍을 주의하라

3. 설계와 구현의 문제

- 포함 has
  - 포함을 통해 갖다를 구현하라
  - 최후의 수단으로 비공개 상속을 통해 has를 구현하라
  - 약 7개 이상의 데이터 멤버를 포함하는 클래스를 주의하라
- 상속 is
  - 공개 상속을 통해 이다를 구현하라
  - 상속을 고려해서 설계하고 문서화하라
  - 리스코프 치환 원칙을 따르라
  - 오버라이드가 불가능한 멤버 함수를 오버라이드 하지 말라
  - 공통으로 사용되는 인터페이스와 데이터, 행위를 상속단계에서 가능한 한 가장 높은 곳으로 옮겨라
  - 인스턴스가 하나뿐인 클래스를 의심하라
  - 파생 클래스가 하나뿐인 기본 클래스를 의심하라
  - 루틴을 오버라이드했는데 파생된 루틴 내부에서는 아무것도 하지 않는 클래스들을 의심하라
  - 깊은 상속구조를 피하라
  - 광범위한 타입 검사보다 다형성을 택하라

## 7장 고급 루틴

루틴 : 한 가지 목적을 위해서 호출할 수 있는 개별 메서드나 프로시저

1. 루틴을 작성하는 이유

- 복잡성을 줄인다.
- 이해하기 쉬운 중간 단계의 추상화를 도입한다.
- 중복 코드를 피한다.
- 서브 클래싱을 지원한다.
- 코드의 실행 순서를 감춘다.
- 포인터 연산을 감춘다.
- 이식성을 높인다.
- 복잡한 불린 테스트를 단순화한다.
- 성능을 개선한다.

2.  루틴 수준의 설계

        1. 응집성
          - *기능성 응집성* : 루틴이 오직 하나의 연산만 처리하는 경우, 이름에서 설명하고 있는 기능을 처리하고 있는 경우
          - 알아둘만한 응집성 : 순차적 응집성, 통신적 응집성, 시간적 응집성
          - 지양해야 하는 응집성 : 절차적 응집성, 논리적 응집성

3.  좋은 루틴의 이름

- 루틴이 하는 모든 것을 표현하라
- 의미가 없거나 모호하거나 뚜렷한 특징이 없는 동사를 사용하지 말라
- 루틴 이름을 숫자만으로 구분하지 말라
- 루틴 이름의 길이에 신경쓰지 말라
- 함수의 이름을 지을 때는 리턴 값에 관해서 설명하라
- 프로시저의 이름을 지을 때 확실한 의미가 있는 동사를 객체 이름과 함께 사용하라
- 반의어를 정확하게 사용하라
- 공통적인 연산을 위한 규약을 만들어라

4. 루틴의 길이에 대한 문제 : 200 줄 이상의 코드는 주의해야한다.
5. 루틴 매개변수 처리

- 매개변수를 입력-수정-출력 순서로 입력한다.
- 고유한 in과 out키워드의 사용을 고려한다.
- 유사한 매개변수가 여러 루틴에서 사용된다면 해당 매개변수를 항상 같은 순서로 입력한다.
- 모든 매개변수를 사용한다.
- 상태 변수나 오류 변수를 마지막에 입력한다.
- 루틴의 매개변수를 연산을 위한 변수로 사용하지 않는다.
- 매개변수에 대한 제약사항을 주석으로 작성한다.
  - 매개변수가 입력을 위한 것인지, 변경되는지, 값을 반환하기 위한 것인지에 대한 내용
  - 숫자 매개변수의 단위
  - 열거형이 아닌 경우 상태 코드와 오류 값의 의미
  - 값의 범위
  - 절대로 가질 수 없는 값
- 루틴 매개변수의 수를 7개 정도로 제한한다.
- 매개변수에 사용할 입력, 수정, 출력 이름 규약을 고려한다.
- 루틴이 인터페이스 추상화를 유지할 수 있도록 변수나 객체를 전달한다.
- 이름 매개변수를 사용한다.
- 실질적인 매개변수가 형식적인 매개변수와 일치하는지 확인한다.

6. 함수를 사용할 대 특별히 고려해야 할 사항

- 함수를 사용할 때와 프로시저를 사용할 때
- 함수 리턴 값 설정
  - 가능한 모든 리턴 경로를 검사하라
  - 지역 데이터에 대한 참조나 포인터를 리턴하지 말라
- 매크로 루틴과 인라인 루틴
  - 매크로 표현식을 괄호로 묶어라
  - 다중 명령문 매크로를 중괄호로 감싸라
  - 필요한 겨우 루틴으로 대체될 수 있도록 매크로 이름을 루틴과 비슷하게 작성하라.

## 8장 방어적 프로그래밍

1. 잘못된 입력으로부터 프로그램 보호

   1. 외부로부터 들어오는 모든 데이터의 값을 검사하라
   2. 루틴의 모든 입력 매개변수 값을 검사하라
   3. 잘못된 입력을 어떻게 처리할 것인지를 결정하라

2. 어설션

- 루틴이나 매크로 실행 시 프로그램이 스스로 검사할 수 있도록 사용하는 코드
- 크고 복잡한 프로그램과 높은 신뢰도를 보장해야 하는 프로그램에서 특히 유용하다
  - 어설션 사용 지침
  1. 발생이 예상되는 상황에 대해서는 오류 처리 코드를 사용하되, 절대로 발생해서는안되는 조건에 대해서는 어설션을 사용하라.
  2. 실행할 가능성이 있는 코드를 어설션 내에 입력하지 않는다.
  3. 선행 조건과 후행 조건을 문서화하고 검증하는데 어설션을 사용하라
  4. 매우 견고한 코드를 작성하기 위해서는 어설션은 무조건 포함하고 그 다음에 오류를 처리하라.

3. 오류처리기법
   1. 중립적인 값을 반환한다.
   2. 다음에 오는 유효한 데이터로 대체한다.
   3. 이전과 같은 값을 반환한다.
   4. 가장 가까운 유효한 값으로 대체한다.
   5. 경고 메세지를 파일에 기록한다.
   6. 오류코드를 반환한다.
   7. 오류 처리 루틴이나 객체를 호출한다.
   8. 오류가 발생한 곳에서 오류 메세지를 출력한다.
   9. 상황에 따라 가장 잘 작동하는 방법으로 오류를 처리한다.
   10. 종료한다.
4. 예외

- 예외를 사용해 무시되어서는 안되는 오류를 프로그램의 다른 부분에 알린다.
- 정말로 예외적인 조건인 경우에만 예외를 던져라
- 책임을 전가하기 위해서 예외를 사용하지 않는다.
- 생성자와 소명자에서 예외를 잡을 수 없다면 생성자와 소멸자에서 예외를 던지지 않는다.
- 올바른 추상화 수준에서 오류를 던진다.
- 예외를 발생시킨 모든 정보를 예외 메세지에 포함한다.
- 비어있는 catch 블록을 피한다.
- 라이브러리 코드가 던지는 예외를 파악한다.
- 중앙 집중화된 예외 보고 시스템 구축을 고려한다.
- 프로젝트의 예외 사용을 규격화한다.
- 예외의 대안을 고려해본다.

5. 오류로 인한 손상을 막기 위한 방책

- 데이터를 입력할 때 적절한 타입으로 변환한다.

6. 디버깅 보조 도구

- 디버깅 보조 도구를 초기에 도입한다.
- 공격적인 프로그래밍 기법을 사용한다.
- 디버깅 보조 도구를 제거하는 계획을 세운다.
  - 버전 관리 도구와 빌드 도구를 사용한다.
  - 기본 제공되는 전처리기를 사용한다.
  - 자신만의 전처리기를 작성한다.
  - 디버깅을 위한 루틴을 작성한다.

7. 얼마나 방어적으로 프로그래밍할 것인지 정하기

- 중요한 오류를 검사하는 코드는 남겨둬라
- 사소한 오류를 검사하는 코드는 제거하라
- 심각한 충돌을 발생시키는 코드를 제거하라
- 프로그램이 우아하게 충돌하도록 돕는 코드를 남겨두라
- 기술지원을 위해서 오류 코드를 기록한다.
- 오류 메세지가 친절한지 확인한다.

8. 방어적 프로그래밍에 대해서 한 번 더 고민하기

## 9장 의사코드 프로그래밍 프로세스

1.  클래스 및 루틴 개발 단계 요약

        1. 클래스 생성 단계
          - 클래스는 일반적인 설계를 작성한다.
          - 클래스 내에 각 루틴을 구현한다.
          - 클래스를 전체적으로 검토하고 테스트 한다.
        2. 루틴을 작성하는 단계
          - 루틴 설계 > 설계 검사 > 코드 작성 > 코드 점검

2.  전문가를 위한 의사코드

- 의사코드 : 알고리즘이나 루틴, 클래스, 프로그램이 어떻게 작동할지를 기숭하는 자연어 문장과 같은 비형식적인 표기법
- 의사코드 프로그래밍 프로세스는 루틴의 코드를 능률적으로 작성하기 위해서 의사코드를 사용하는 특수한 접근 방법을 정의한다.

3.  PPP(Pseudocode Programming Process)를 이용한 루틴 구현

        1. 루틴을 설계한다.
          - 선행 조건을 검사한다.
          - 루틴을 해결할 문제를 정의한다.
          - 루틴의 이름을 짓는다.
          - 루틴을 어떻게 테스트 할 것인지 결정한다.
          - 표준 라이브러리에서 사용할 수 있는 기능을 조사한다.
          - 오류 처리에 대해서 생각한다.
          - 효율성에 대해서 생각한다.
          - 알고리즘과 데이터형을 조사한다.
          - 의사코드를 작성한다.
          - 데이터에 대해서 생각한다.
          - 의사코드를 검사한다.
          - 의사코드에서 몇 가지 아이디어를 내보고 가장 좋은 방법을 선택한다.

        2. 루틴을 구현한다.
          - 루틴의 선언부를 작성한다.
          - 의사코드를 고수준의 주석으로 변환한다.
          - 각 주석 아래에 코드를 채운다.
          - 코드를 더 나눠야 하는지 검사한다.

        3. 코드를 검사한다.
          - 머릿속에서 루틴의 오류를 검사한다.
          - 루틴을 컴파일한다.
          - 코드를 디버거에서 한 단계씩 살펴본다.
          - 코드를 테스트한다.
          - 루틴에 있는 오류를 제거한다.

        4. 나머지를 정리한다.
        5. 필요한만큼 반복한다.

4.  PPP 대안

- 테스트 주도 개발
- 리팩터링
