---
title: "코드 컴플리트3"
category: "book"
date: "2022-07-31"
---

## 10장 변수 사용 시 고려사항

1.  변수선언을 쉽게 만드는 방법

        1. 암시적 선언기능을 사용하지 않는다.
        2. 모든 변수를 선언한다.
        3. 이름 규칙을 정한다.
        4. 변수 이름을 검사한다.

2.  변수 초기화 가이드라인

        1. 변수를 선언할 때 초기화한다.
        2. 변수가 처음 사용되는 곳 근처에서 초기화한다.
        3. 이상적으로 각 변수가 처음 사용되는 곳 가까이에서 변수를 초기화하고 정의한다.
        4. 가능하다면 final이나 const를 사용한다.
        5. 카운터와 누산기를 특히 주의한다.
        6. 클래스의 멤버 데이터를 생성자에서 초기화한다.
        7. 다시 초기화해야 할 필요가 있는지 검사한다.
        8. 이름 상수를 한 번 초기화라고 실행 코드로 변수를 초기화한다.
        9. 모든 변수를 자동으로 초기화하는 컴파일러 설정을 사용한다.
        10. 컴파일러의 경고 메세지를 활용한다.
        11. 입력 매개변수의 유효성을 검사한다.
        12. 메모리 접근 도구를 사용해 부적절한 포인터를 검사한다.
        13. 프로그램을 시작할 때 메모리를 초기화한다.

3.  범위

        1. 변수에 대한 참조를 지역화하라
        2. 변수의 수명을 가능한 짧게 유지하라
          - 변수를 사용하기 바로 전까지 변수에 값을 할당하지 않는다.
          - 연관된 명령문을 그룹화한다.
          - 연관된 명령문 그룹을 별도 루틴으로 나눈다.
          - 처음에는 범위를 최대한 제한하고 필요한 경우에만 변수의 범위를 늘린다.

4.  지속성 - 데이터 수명

        1. 특정한 코드 블록이나 루틴에서만 살아있는 경우
        2. 특정 기간만 살아있는 경우
        3. 프로그램이 종료할 때까지 살아있는 경우
        4. 영원이 살아있는 경우

5.  결합시점 - 변수와 값이 서로 연결된 시점

        결합시점을 늦출수록 코드는 유연해진다.
        - 코드 작성 시간 - 매직넘버 사용
        - 컴파일 시간 - 이름 상수 사용
        - 로드 시간 - 외부의 소스로부터 값을 읽어들임
        - 객체 생성 시간 - 윈도우가 생성될 때마다 값을 읽어들임
        - 적시에 - 윈도우가 그려질 때마다 값을 읽어들임

6.  데이터형과 제어 구조 사이의 관계

- 순차적 데이터는 프로그램의 순차적 명령문으로 변환한다.
- 선택적 데이터는 프로그램에서 if와 case 명령문으로 변환한다.
- 반복되는 데이터는 프로그램에서 for, repeat, while 루프 구조로 변환한다.

7. 변수를 한 가지 목저그로만 사용하기

- 각 변수를 한 가지 목적만을 위해서 사용하라
- 숨은 의미가 있는 변수를 피하라
- 선언된 모든 변수를 사용하는지 확인하라

## 11장 변수 이름의 기능

1. 좋은 이름을 짓기 위한 고려사항

- 문제지향
- 최적의 이름길이
- 범위에 따른 변수명 지정
- 변수 이름의 계산값 한정자
  - Total, Sum, Average, Max, Min, Record, String, Pointer
- 일반적인 변수명의 반의어
  - begin/end
  - first/last
  - min/max
  - locked/unlocked
  - next/previous
  - old/new
  - opened/closed
  - visible/invisible
  - source/target
  - source/destination
  - up/down

2. 특정 타입의 데이터 이름 짓기

- 반복문 인덱스 이름
- 상태 변수 이름
- 임시 변수 이름
  - 정보가 없는 임시변수보다는 실질적인 변수를 사용하는 것이 좋다.
- 불린 변수 이름
  - 전형적인 불린 변수의 이름을 기억한다.
    - done : 수행이 완료되었음을 의미할 때 사용.
    - error : 오류가 발생했음을 의미할 때 사용.
    - found: 값이 발견되었음을 의미할 때 사용.
    - success: 연산이 성공했을 때 사용.
  - 참이나 거짓의 의미를 함축하는 불린 변수의 이름을 사용한다.
  - 긍정적인 불린 변수의 이름을 사용한다.
- 열거형의 이름
  - 열거형이 본질적으로는 사용자 정의형
- 상수이름
  - 상수가 가리키는 숫자보다는 상수가 표현하는 추상적인 대상을 나타내야한다.

3. 이름 규약의 효과

- 장점
  - 코드의 가독성이 높아지고 코드를 파악하는 시간이 줄어들어 생산성이 높아진다.
  - 중복 변수를 줄여준다. 서로 같은 것을 다른 이름으로 만드는 일이 줄어들어 중복 변수 선언이 줄어든다.
  - 언어의 약점을 보완한다. 지역 데이터, 클래스 데이터, 전역 데이터를 구별할 수 있으며 컴파일러가 지원하지 않는 타입에 대한 타입 정보를 만들 수 있다.
- 규약이 필요한 시점
  - 여러 개발자가 하나의 프로젝트를 함께 진행할 때
  - 변경이나 유지보수 등으로 다른 개발자와 함께 작업해야 할 때
  - 프로그램이 너무 커서 한 번에 기억할 수 없기 때문에 부분적으로 나누어서 생각해야 할 때
  - 프로그램이 수명이 길어서 나중에 다시 작업해야 할 때
  - 프로젝트에서 사용하는 특이한 용어들이 있을 때

4. 비형식적인 이름 규약

- 변수의 이름과 루틴의 이름을 구별한다.
- 클래스와 객체를 구별한다.
- 전역 변수를 식별한다.
- 멤버 변수를 식별한다.
- 타입 선언을 식별한다.
- 이름 상수를 식별한다.
- 열거형의 요소를 식별한다.
- 입력만 하는 매개변수를 지정할 수 없는 언어에서는 이를 식별한다.
- 가독성을 위해 이름에 서식을 지정한다.

변수는 세가지 정보를 포함한다.

- 변수의 내용 : 무엇을 표현하는가
- 데이터의 종류 : 이름 상수나 기본 변수, 사용자 정의형, 클래스
- 변수의 범위 : 지역이나 클래스, 패키지, 전역

5. 표준 접두사

- 사용자 정의형(User-Defined Type, UDT) : 화면 영역, 폰트 등을 가리킴
- 의미적 접두사(c, first, g, i,last, lim, m, max, min, p)

이름은 코드를 작성하는 사람보다 읽는 사람에게 더 중요하다는 점을 기억한다.

## 12장 기본 데이터형

1. 숫자 일반

- 매직 넘버를 피한다. 아무런 설명도 없이 프로그램 중간에 사용되는 숫자
- 필요하다면 0과 1은 그냥 사용한다.
- 0으로 나눔 오류를 미리 방지한다.
- 형 변환을 명시적으로 처리한다.
- 서로 다른 형을 비교하지 않는다.
- 컴파일러의 경고에 주의를 기울인다.

2. 정수

- 정수 나눗셈을 검사한다.
- 정수 오버플로를 검사한다.
- 중간 결과에서의 오버플로를 검사한다.

3. 부동 소수점 수

- 서로 크기가 매우 다른 수를 더하거나 빼지 않는다.
- 동치 비교를 피한다.
- 라운딩 오류를 예측한다.

4. 문자와 문자열

- 매직 문자와 문자열을 사용하지 않는다.
- 하나 차이로 인한 오류를 주의한다.
- 자신이 사용하고 있는 언어와 환경에서 유니코드를 어떻게 지원하는지 알아둔다.
- 국제화/지역화 전략을 초기에 결정한다.
- 알파벳 기반의 단일 언어를 지원할 필요가 있다는 사실을 안다면 ISO 8859 문자 집합 사용을 고려한다.
- 다중 언어를 지원해야한다면 유니코드를 사용한다
- 문자열 형 사이에 일관된 변환 전략을 결정한다.

5. 불린 변수

- 프로그램을 문서화 하기 위해서 불린 변수를 사용한다.
- 복잡한 테스트는 단순화하기 위해 불린 변수를 사용한다.
- 필요하다면 사용자 정의 불린 형을 만든다.

6. 열거형

- 가독성 향상을 위해서 열거형을 사용하라
- 안정성을 위해 열거형을 사용하라
- 변경하기 쉽게 열거형을 사용하라
- 불린 변수에 대한 대안으로 열거형을 사용하라
- 유효하지 않은 값을 검사하라
- 반복문의 범위를 지정하기 위하여 열거의 처음과 마지막 항목을 정의하라
- 열거형의 첫 번째 항목을 유효하지 않은 값으로 남겨라
- 프로젝트 코드 작성 표준에서 처음과 마지막 요소가 어떻게 사용될 것인지 정확하게 정의한 후 일관성 있게 사용하라
- 열거형의 요소에 명시적인 값을 할당할 때 발생할 수 있는 위험 요소를 주의하라

7. 이름 상수

- 데이터 선언에 이름 상수를 사용하라
- 명백한 리터럴이라도 리터럴은 피하라
- 범위가 적절하게 지정된 변수나 클래스를 사용하여 이름 상수를 흉내내라
- 이름 상수를 일관성이 있게 사용하라

8. 배열

- 배열의 모든 인덱스가 배열의 경계 내에 있는지 확인하라
- 배열 대신 컨테이너 사용을 고려하거나 배열을 순차적인 구조체로 생각하라
- 배열의 마지막 위치를 확인하라
- 인덱스가 혼성되지 않도록 주의하라

9. 새로운 형 만들기

- 새로운 형을 만들어야 하는 이유
  - 수정하기 쉬워진다.
  - 과도하게 정보를 분산시키는 것을 피할 수 있다.
  - 신뢰성을 향상시킨다.
  - 언어의 약점을 보완한다.
- 새로운 형을 만들기 위한 지침
  - 기능 지향적인 이름으로 형을 생성하라
  - 미리 정의된 형을 가리키는 형 이름을 조심하라
  - 미리 정의된 형을 피하라
  - 미리 정의된 형을 재정의하지 말라
  - 다른 플랫폼으로 이식하기 쉽게 대체 형을 정의하라
  - 미리 정의된 형으로 쉽게 오인할 수 있는 형은 선언하지 말라
  - typedef를 사용하는 대신 클래스 생성을 고려하라

## 13장 특이한 데이터형

1. 구조체
   서로 다른 형의 집합으로 구성된 데이터

- 데이터 관계를 이해하기 쉽게 하기 위해서 사용하라
- 데이터 블록에 대한 작업을 단순화하기 위해서 구조체를 사용하라
- 매개변수 목록을 단순화하기 위해서 구조체를 사용하라
- 유지보수를 줄이기 위해서 구조체를 사용하라

2. 포인터

- 포인터를 이해하는 패러다임
  - 메모리 상에서의 위치
  - 메모리의 내용을 해석하는 방법
- 포인터 사용 팁
  - 포인터 연산을 루틴이나 클래스에 고립시켜라
  - 포인터를 선언과 동시에 정의하라
  - 포인터를 할당된 곳과 같은 영역에서 삭제하라
  - 포인터를 사용하기 전에 검사하라
  - 포인터가 참조하는 변수를 사용하기 전에 검사하라
  - 손상된 메모리를 검사하는 인식표 필드를 사용하라
  - 명시적으로 중복 추가하라
  - 여분의 포인터 변수를 사용하라
  - 복잡한 포인터 표현식을 단순화하라
  - 그림을 그려라
  - 링크드 리스트에 있는 포인터를 올바른 순서로 삭제해라
  - 임시 메모리를 할당하라
  - 쓰레기를 확실하게 삭제하라
  - 변수를 삭제하기 전에 잘못된 포인터를 검사하라
  - 포인터 할당을 추적하라
  - 포인터 문제를 피하기 위해 커버 루틴을 작성하라

3. 전역 데이터

- 전역 데이터를 사용할 때 발생하는 일반적인 문제점

  - 전역 변수에 대한 부주의한 변경
  - 전역 데이터의 기괴하고 이상한 별칭 문제
  - 전역 데이터의 재진입 코드 문제
  - 전역 데이터로 인한 코드 재사용 문제
  - 불확실한 초기화 순서 문제점
  - 손상되는 모듈화와 지적인 관리 용이성

- 전역 데이터를 사용하는 이유

  - 전역적인 값을 보관
  - 이름 상수의 역할
  - 열거형 흉내내기
  - 매우 자주 사용되는 데이터의 사용 능률화
  - 뜨내기 데이터 제거

- 최후의 수단으로만 전역 데이터를 사용하라
- 전역 데이터 대신 접근 루틴 사용
