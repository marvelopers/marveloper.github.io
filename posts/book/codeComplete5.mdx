---
title: "코드 컴플리트4"
category: "book"
date: "2022-07-31"
---

## 20장 소프트웨어 품질

1. 소프트웨어 품질의 특성

- 외적인 특성

  - 정확성
  - 사용성
  - 효율성
  - 신뢰성
  - 무결성
  - 적응성
  - 정밀성
  - 견고성

- 내적인 특성
  - 유지보수성
  - 유연성
  - 이식성
  - 재사용성
  - 테스트 용이성
  - 이해 용이성

2. 소프트웨어 품질을 향상시키기 위한 기법들

- 소프트웨어 품질의 목표
- 명확한 품질 보증 활동
- 테스트 전략
- 소프트웨어 공학 가이드라인
- 비형식적인 기술적 검토
- 절차를 따르는 기술적 검토
- 외부 감사

- 개발 프로세스 : 변경관리 과정, 결과 측정, 프로토 타이핑

3. 품질 향상 기법의 상대적 효과성
4. 품질 보증 활동 시기
5. 소프트웨어 품질의 일반적인 원칙

## 21장 협력 구현

1. 협력 개발 방법 필요
2. 짝 프로그래밍
3. 공식적인 정밀 검토
4. 여러가지 협력 개발 방법

## 22장 개발자 테스트

1. 소프트웨어 품질에서 개발자 테스트의 역할
2. 개발자 테스트에 대한 바람직한 접근 방법

- 개발자 테스트의 한계
  - 개발자 테스트는 깨끗한 테스트가 되기 쉽다
  - 테스트 커버리지를 낙관적으로 보는 경향이 있다.
  - 좀 더 정교한 테스트 커버리지를 건너뛰는 경향이 있다.

3. 여러가지 교모한 테스트 방법

- 불완전한 테스트
- 구조적인 기초 테스트
- 데이터 흐름 테스트
- 데이터 상태의 조합
  - 정의-정의
  - 정의-빠져나옴
  - 정의-삭제
  - 들어감-삭제
  - 들어감-사용
  - 삭제-삭제
  - 삭제-사용
  - 사용-정의
- 등가분할
- 오류추측
- 경계분석
- 복합경계
- 나쁜 데이터
  - 너무 적은 데이터, 너무 많은 데이터, 유효하지 않은 데이터, 잘못된 크기의 데이터, 초기화되지 않은 데이터
- 좋은 데이터
  - 명목상 케이스, 일반적이고 예상된 값
  - 최소한의 정상적인 구성
  - 최대한의 정상적인 구성
  - 이전 데이터와의 호환
- 수동 점검이 편리한 테스트 케이스를 사용하라

4. 전형적인 오류

- 오류의 분류
  - 대부분의 오류가 발생하는 범위는 상당히 제한되어 있다.
  - 많은 오류가 구현 범위 밖에 있다.
  - 대부분의 구현 오류는 프로그램의 잘못이다.
  - 오타는 뜻밖에 많이 발생하는 문제다.
  - 설계를 잘못 이해하는 것은 프로그램의 오류에 대한 연구에서 계속해서 나타나는 주제다.
  - 대부분의 오류는 수정하기 쉽다.
  - 자신이 속한 조직의 오류에 대한 경험을 측정하는 것은 좋은 생각이다.

5. 테스트 지원 도구

- 개별 클래스를 테스트하는 비계 구축
- 차이 분석 도구
- 테스트 커버리지 모니터
- 데이터 기록/로깅
- 시스템 교란기
- 오류 데이터 베이스

6.  테스트를 향상시키는 방법

    1. 테스트 계획 세우기
    2. 다시 테스트하기

       - 자동 테스트

7.  테스트 기록을 보존하는 방법

## 23장 디버깅

1. 디버깅 이슈 소개

- 기회로서의 결함
  - 개발 중인 프로그램에 관계 배울 수 있다
  - 자신이 저지른 실수에 관해 배울 수 있다
  - 자신이 코드를 읽어야 하는 사람으로부터 코드의 품질에 관해 배울 수 있다.
  - 문제를 해결하는 방법을 배울 수 있다.
  - 결함을 수정하는 방법을 배울 수 있다.

2. 결함 발견
3. 결함 수정
4. 디버깅에서 심리학적으로 고려해야 할 상황
5. 디버깅도구

## 24장 리팩터링

1. 리팩터링 소개

- 소프트웨어를 더 쉽게 이해하고 적은 비용으로 수정할 수 있도록 외부 동작의 변화 없이 내부 구조를 변경하는 것
- 리팩터링 하는 이유
  - 코드가 중복되어 있다.
  - 루틴이 너무 길다.
  - 루프가 너무 길거나 깊이 중첩되어 있다.
  - 클래스의 응집력이 약하다.
  - 클래스 인터페이스가 일관된 추상화 수준을 제공하지 않는다.
  - 매개변수가 너무 많다.
  - 클래스 내의 변경 사항이 상호 관계를 고려하지 않고 구분되는 경향이 있다.
  - 변결할 때 여러 개의 클래스를 동시에 수정해야 한다.
  - 상속 계층 구조가 병렬로 변경되어야 한다.
  - case문이 병렬로 변경되어야 한다.
  - 함께 사용되는 연관된 데이터 항목이 클래스로 구성되지 않았다.
  - 루틴이 자신이 포함된 클래스보다 다른 클래스의 기능을 더 많이 사용한다.
  - 클래스가 많은 일을 수행하지 않는다.
  - 일련의 루틴이 뜨내기 데이터를 전달한다.
  - 중개 역할을 하는 객체가 아무것도 하지 않는다.
  - 한 클래스가 지나치게 다른 클래스를 참견한다.
  - 루틴의 이름이 엉성하다.
  - 공개 데이터 멤버다
  - 서브 클래스는 부모 클래스 루틴의 일부만을 사용한다.
  - 주석을 이용해 어려운 코드를 설명한다.
  - 전역 변수를 사용한다.
  - 루틴이 루틴을 호출하기 전에 설정 코드를 사용하거나 루틴을 호출한 다음에 분해 코드를 사용한다.
  - 프로그램이 언젠가 필요할 것 같은 코드를 포함하고 있다.

2. 구체적인 리팩터링

- 데이터 수준 리팩터링
  - 매직 넘버를 이름 상수로 대체한다.
  - 변수 이름을 더 분명하고 많은 정보를 제공하는 이름으로 다시 짓는다.
  - 표현식을 인라인화 한다
  - 표현식을 루틴으로 대체한다.
  - 중간 변수를 사용한다.
  - 여러 목적으로 사용되는 변수를 단일 목적을 갖는 변수 여러개로 변환한다.
  - 로컬에서 사용할 목적이라면 매개변수 대신 지역 변수를 사용한다.
  - 기본현 데이터를 클래스로 변환한다.
- 명령문 수준 리팩터링
  - 불린 표현식을 분해한다.
  - 복잡한 불린 표현식을 명확한 이름의 불린 함수로 옮긴다.
  - 서로 다른 조건문 내에 중복으로 사용된 코드를 결합한다.
  - 루프 제어 변수 대신 break 나 return을 사용하낟.
  - 중첩된 if else 명령문 내에서 리턴값을 할당하는 대신, 답을 알았을 대 곧바로 리턴한다.
  - 조건문을 다형성으로 대체한다.
  - 널 값을 테스트하는 널 객체를 생성하여 사용한다.
- 루틴 수준 리팩터링
  - 루틴을 추출한다.
  - 루틴의 코드를 인라인화한다.
  - 긴 루틴을 클래스로 변환한다.
  - 복잡한 알고리즘 대신 간단한 알고리즘을 사용한다.
  - 매개변수를 추가한다.
  - 매개변수를 제거한다.
  - 변경 연산과 쿼리 연산을 구분한다.
  - 매개변수를 이용하여 유사한 루틴을 결합한다.
  - 전달되는 매개변수에 따라 행복하는 루틴을 분리한다.
  - 특정한 필드 대신 전체 객체를 전달한다.
  - 전체 객체 대신 특정한 필드만 전달한다.
  - 다운 캐스팅을 캡슐화 한다.
- 클래스 구현 리팩터링
  - 값 객체를 참조 객체로 변경한다.
  - 참조 객체를 값 객체로 변경한다.
  - 가상 루틴을 데이터 초기화로 대체한다.
  - 멤버 루틴이나 데이터의 위치를 변경한다.
  - 특화된 코드를 서브 클래스로 추출한다.
  - 유사한 코드를 슈퍼클래스로 결합한다.
- 클래스 인터페이스 리팩터링
  - 루틴을 다른 클래스로 이동시킨다
  - 한 클래스를 두 개로 변환한다
  - 클래스를 제거한다
  - 위임을 숨긴다
  - 중개자를 제거한다
  - 상속을 위임으로 대체한다
  - 위임을 상속으로 대체한다
  - 외부 루틴을 도입한다
  - 확장 클래스를 도입한다
  - 노출된 멤버 변수를 캡슐화한다
  - 변경할 수 없는 필드에 대한 set() 루틴을 제거한다
  - 클래스 외부에서 사용하면 안 되는 루틴을 숨긴다
  - 사용되지 않는 루틴을 캡슐화한다
  - 슈퍼클래스와 서브클래스의 구현이 매우 유사하다면 이 둘을 결합한다.
- 시스템 수준 리팩터링
  - 제어할 수 없는 데이터에 대해 명확한 참조 소스를 생성한다
  - 단방향 클래스 관계를 양방향 클래스 관계로 바꾼다
  - 양방향 클래스 관계를 단방향 클래스로 관계로 바꾼다
  - 간단한 생성자 대신 팩토리 메서드를 제공한다
  - 오류 코드를 예외로 대체하거나 그 반대로 한다

3. 안전한 리팩터링 방법

- 리팩토링을 시작하기 전에 코드를 저장한다
- 리팩터링을 작게 유지한다
- 리팩터링을 한 번에 하나만 수행한다
- 수행할 단계에 대한 목록을 만든다
- 주차장을 만든다
- 체크 포인트를 자주 설정한다
- 컴파일러 경고를 활용한다
- 다시 테스트한다
- 테스트 케이스를 추가한다
- 변경 사항을 검토한다
- 리팩터링 위험 수준에 따라서 접근 방법을 조절한다

- 코드를 작성하고 수정하는 것을 감추는 용도로 리팩터링을 사용하지 않는다
- 코드르 재작성하는 대신 리팩터링하지 않는다

4. 리팩터링 전략

- 루틴을 추가할 때 리팩터링한다
- 클래스를 추가할 때 리팩터링한다
- 결함을 수정할 때 리팩터링한다
- 오류를 유발할 가능성이 있는 모듈을 대상으로 삼는다
- 복잡도가 높은 모듈을 대상으로 삼는다
- 유지보수 환경에서는 자신이 맡은 부분을 개선한다
- 정보된 코드와 엉성한 코드 사이의 인터페이스를 정의한 후 인터페이스를 통해 코드르 이동한다

* 프로그램이 초기 개발 시와 초기 배포 후에 변경될 수 있다는 것은 엄연한 인생의 현실이다
* 소프트웨어는 변경될 때 향상되거나 손상될 수 있다. 소프트웨어 진화의 기본 원칙은 코드가 진화할 때 반드시 내부적인 품질이 향상되어야 한다는 것이다
* 리팩터링을 성공적으로 수행하기 위한 핵심 요건은 다양한 경고 표시나 리팩터링이 필요하다는 것을 암시하는 냄새에 주의를 기울이는 것이다
* 리팩터링을 성공적으로 수행하기 위한 또 다른 핵심요소는 수많은 리팩터링을 학습하는 것이다. 또한 리팩터링을 안전하게 수행하기 위한 전략을 갖는 것이다. 어떤 리팩터링 접근 방법은 다른 것보다 더 좋다
* 개발 중에 리팩터링하면 프로그램을 향상시키고 처음에 만들고자 했던 대로 프로그램을 변경할 수 있는 최고의 기회를 얻게 된다. 개발 중에 그러한 기회를 적극적으로 활용하도록 한다.

## 25장 코드 튜닝 전략

1960년대 컴퓨터의 자원이 한정적이었기 때문에 효율화가 최고의 관심사였다.
성능은 전략과 전술이라는 두 가지 측명에서 설명할 수 있다.

1. 성능이란

- 품질의 특성과 성능
- 성능과 코드 튜닝
  - 프로그램 요구사항
  - 프로그램 설계
  - 클래스와 루틴 설계
  - 운영체제 상호작용
  - 코드 컴파일
  - 하드웨어
  - 코드 튜닝

2. 코드 튜닝 소개

- 성능을 향상시키는 가장 효과적인 방법은 아님.
- 파레토의 법칙
- 노부인들의 이야기
  - 거짓 고급언어에서 코드를 줄이면 결과적으로 기계어 코드의 속도나 크기를 향상시킨다
  - 거짓 어떤 연산이 아마 다른 것보다 빠르거나 작을 것이다
  - 거짓 코드를 작성하면서 최적화해야한다
  - 거짓 빠른 프로그램은 정확한 프로그램만큼 중요하다
- 튜닝 시점
  - 고급 설계를 사용하라
- 컴파일러 최적화

3. 느리고 비대한 부분

- 비효율성의 공통적인 원인
  - 입력/ 출력 연산
  - 페이징
  - 시스템 호출

4.  측정
5.  반복

6.  코드 튜닝 단계 요약

        1. 이해하고 변경하기 쉬운 잘 설계된 코드를 사용하여 소프트웨어를 개발한다
        2. 성능이 좋지 못하면
          - 나중에 돌아올 수 있도록 버전 코드를 저장한다
          - 과열 지점을 찾기 위해서 시스템을 측정한다
          - 성능 취약의 원인을 찾는다 (부적절한 설계, 데이터형, 알고리즘 등)
          - 병목을 튜닝
          - 한 번에 하나의 선능을 측정한다
          - 코드의 성능이 향상되지 않았다면 롤백한다
        3. 2단계를 반복한다

## 26장 코드 튜닝 기법

1. 논리구조

- 답을 알고 있는 테스트를 중단하라
- 빈도에 따른 테스트 정렬
  - 가장 빈도가 많은 테스트가 먼저 수행되로록 정렬한다
- 유사한 논리구조의 성능을 비교하라
- 복잡한 표현식을 테이블 참조로 대체하라
- 소극적 평가를 사용하라

2. 반복문

- 스위칭 해제
- 코드 풀어쓰기
- 반복문 내부 작업 최소화
- 감시값
- 가장 빈복하게 실행되는 반복문을 안쪽에 작성한다
- 연산 줄이기

3. 데이터 변환

- 부동 소수점 수 대신 정수를 사용하라
- 가능한 한 가장 적은 차수의 배열을 사용하라
- 배열에 대한 참조를 최소화하라
- 참조 인덱스를 사용하라
  - 문자열 길이 인덱스
  - 독립적인 병렬 인덱스 구조
- 캐싱을 사용하라

4. 표현식

- 대수 항등식을 사용하라
- 연산 줄이기
  - 곱셈을 덧셈으로 대체
  - 거듭제곱은 곱셈으로 대체
  - 삼각법 루틴을 삼각법 항등식으로 대체
  - longlong 정수를 long이나 int로 대체
  - 부동 소수점 수를 고정 소수점 수나 정수로 대체
  - 배정도 부동 소수점을 단정도 부동 소수점 수로 대체
  - 정수에 2를 곱하거나 2를 나누는 계산을 shift 연산으로 대체
- 컴파일 시간을 초기화하라
- 시스템 루틴을 주의하라
- 상수의 정확한 타입을 사용하라
- 결과를 사전에 계산하라
- 공통적인 하위 표현식을 제거하라

5. 루틴

- 루틴을 인라인으로 재작성하라

6. 저급언어를 이용한 재구성

7. 변경이 많을수록 상태는 그대로

- 최적화의 결과는 프로그래밍 언어, 컴파일러, 환경에 따라 크게 달라진다. 최적화 작업마다 결과를 측정하지 않으면 그것이 프로그램에 도움이 되는지 해가 되는지 알 수 없을 것이다
- 첫 번째 최적화는 일반적으로 최석의 솔루션이 아니다. 좋은 최적화 방법을 발견한 후에도 좀 더 좋은 것을 계속해서 찾는다
- 코드 튜닝은 핵에너지와 약간 비슷하다. 논쟁의 여지가 있고 감정적인 주제다. 어떤 사람들은 신뢰성을 떨어뜨리고 유지보수하기 어려워진다는 이유로 코드 튜닝을 전혀 하지 않으려고 한다. 다른 사람들은 적절한 방어택이 있다면 코드 튜닝이 유용하다고 생각한다. 이 장에서 소개한 기법을 사용하기로 한다면 주의해서 적용한다.
